{"version":3,"sources":["bindings/workers.ts","worker.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAyCC,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,YAAA,QAAA,UAAA,QAAA,YAAA,EAzCD,IAAA,EAAA,QAAA,oBAIA,IAAI,EAAY,EAAa,EAE7B,GAmCC,QAAA,UAAA,EAAA,QAAA,YAAA,EAAA,QAAA,OAAA,EAnCG,EAAJ,UACI,QAAA,OAAA,EAAa,KAAK,OAClB,QAAA,YAAA,EAAc,KAAK,YACnB,QAAA,UAAA,EAAa,CAAA,GAAY,iBAAiB,UAAW,SAEpD,GAAI,EAAJ,OAAY,CACP,MAAA,EAAoB,QAAS,kBAG7B,MAAA,EAEF,YAAY,GACH,KAAA,OAAS,IAAI,EAAc,OAAO,GAE3C,iBAAiB,EAAmB,GAC3B,KAAA,OAAO,GAAG,EAAY,IACvB,EAAQ,CAAC,KAAM,MAGvB,YAAY,GACH,KAAA,OAAO,YAAY,GAErB,iBAAU,GACb,EAAc,WAAW,GAAG,UAAY,IACpC,EAAQ,CAAC,KAAM,MAGhB,mBAAY,GACf,EAAc,WAAW,YAAY,IAI7C,QAAA,OAAA,EAAa,EACb,QAAA,UAAA,EAAY,EAAc,UAC1B,QAAA,YAAA,EAAc,EAAc;;ACKZ,aA1CpB,IAAA,EAAA,QAAA,UACA,EAAA,QAAA,wBACA,EAAA,QAAA,sBAGA,MAAM,EAAO,IAAI,EAAJ,SAAa,CAAC,KAAK,KAEhC,EAAY,EAAA,aAAA,EAAK,SAEjB,EAAK,GAAG,aAAgB,IAAM,EAAY,EAAA,aAAA,IAC1C,EAAK,IAAI,GAAG,OAAY,IAAM,EAAY,EAAA,aAAA,CAAC,MAAO,WAAY,IAAK,KACnE,EAAK,KAAK,GAAG,UAAW,IAAM,EAAY,EAAA,aAAA,CAAC,MAAO,UAAW,IAAK,MAElE,EAAU,EAAA,WAAA,MAAA,IACF,GAAA,EAAG,KAAK,OACH,IAAA,IAAI,KAAM,EAAG,KAAK,OACnB,EAAK,OAAO,GAAG,cAAc,EAAI,EAAG,KAAK,OAAO,IAMpD,GAHA,EAAG,KAAK,QACR,EAAK,QAAQ,EAAa,aAAA,KAAK,EAAG,KAAK,SAEvC,EAAG,KAAK,KACH,IAAA,IAAI,KAAO,EAAG,KAAK,KAAK,SAAW,GACpC,EAAK,KAAK,KAAK,QAAQ,EAAI,KAAM,EAAI,IAAK,EAAI,OAGlD,GAAA,EAAG,KAAK,KAAM,CACV,IAAA,EAAO,EAAG,KAAK,KAAM,EAAO,EAAG,KAAK,MAAQ,EAAG,KAAK,KAAK,KACzD,EAAM,EAAG,KAAK,MAAQ,EAAG,KAAK,KAAK,IACnC,IACI,IAAA,QAAiB,EAAK,MAAM,EAAM,EAAM,IAChC,EAAA,EAAA,aAAA,CAAC,MAAO,OAAQ,IAAK,CAAC,KAAM,KAE5C,MAAO,IACS,EAAA,EAAA,aAAA,CAAC,MAAO,QAAS,IAAK,QAO9C,KAAK,KAAO","file":"worker.8e73be95.js","sourceRoot":"../../src/kernel","sourcesContent":["import { isNode, isBrowser } from '../../infra/arch';\nimport { Worker as WorkerThread } from 'worker_threads';\n\n\nlet WorkerImpl, postMessage, onMessage;\n\nif (isBrowser) {\n    WorkerImpl = self.Worker;\n    postMessage = self.postMessage;\n    onMessage = (handler) => addEventListener('message', handler);\n}\nelse if (isNode) {\n    const workerThreads = (0||require)('worker_threads');\n\n    // @ts-ignore\n    class WorkerAdapter implements Worker {\n        thread: WorkerThread;\n        constructor(stringUrl: string) {\n            this.thread = new workerThreads.Worker(stringUrl);\n        }\n        addEventListener(eventName: string, handler: (ev: any) => void): void {\n            this.thread.on(eventName, (ev) => {\n                handler({data: ev});\n            });\n        }\n        postMessage(msg: any) {\n            this.thread.postMessage(msg);\n        }\n        static onMessage(handler: (ev: any) => void) {\n            workerThreads.parentPort.on('message', (ev) => {\n                handler({data: ev});\n            });\n        }\n        static postMessage(msg: any) {\n            workerThreads.parentPort.postMessage(msg);\n        }\n    }\n\n    WorkerImpl = WorkerAdapter;\n    onMessage = WorkerAdapter.onMessage;\n    postMessage = WorkerAdapter.postMessage;\n}\n\n\n\nexport { WorkerImpl as Worker, onMessage, postMessage };    \n","// build with\n// parcel watch --no-hmr src/kernel/worker.ts\n\nimport { ExecCore } from \"./exec\";\nimport { SharedVolume } from \"./services/shared-fs\";\nimport { postMessage, onMessage } from './bindings/workers';\n\n\nconst core = new ExecCore({tty: true});\n\npostMessage(core.share());\n    \ncore.on('stream:out',   ev => postMessage(ev));\ncore.tty.on('data',     ev => postMessage({event: 'tty:data', arg: ev}));\ncore.proc.on('syscall', ev => postMessage({event: 'syscall', arg: ev}));\n\nonMessage(async (ev) => {\n    if (ev.data.upload) {\n        for (let fn in ev.data.upload) {\n            core.wasmFs.fs.writeFileSync(fn, ev.data.upload[fn]);\n        }\n    }\n    if (ev.data.volume) {\n        core.mountFs(SharedVolume.from(ev.data.volume));\n    }\n    if (ev.data.dyld) {\n        for (let lib of ev.data.dyld.preload || []) {\n            core.proc.dyld.preload(lib.name, lib.uri, lib.reloc);\n        }\n    }\n    if (ev.data.exec) {\n        let wasm = ev.data.exec, argv = ev.data.opts && ev.data.opts.argv,\n            env = ev.data.opts && ev.data.opts.env;\n        try {\n            let exitcode = await core.start(wasm, argv, env);\n            postMessage({event: 'exit', arg: {code: exitcode}});\n        }\n        catch (e) {\n            postMessage({event: 'error', arg: e});\n        }\n    }\n});\n\n\n// @ts-ignore\nself.core = core;   // useful for debugging"]}