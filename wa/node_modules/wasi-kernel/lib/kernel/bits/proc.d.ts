/// <reference types="node" />
import path from 'path';
import { EventEmitter } from 'events';
import { ExecCore } from '../exec';
import { SharedQueue } from './queue';
import { DynamicLoader } from './dyld';
declare class Proc extends EventEmitter {
    core: ExecCore;
    opts: ProcOptions;
    sigvec: SignalVector;
    childq: ChildProcessQueue;
    dyld: DynamicLoader;
    childset: Set<number>;
    onJoin: (onset: ExecvCall | Error) => void;
    pending: (() => void)[];
    funcTable?: WebAssembly.Table;
    debug: (...args: any) => void;
    constructor(core: ExecCore, opts?: ProcOptions);
    init(): void;
    get import(): {
        __indirect_function_table: WebAssembly.Table;
        debug: (message: string) => void;
    };
    get extlib(): {};
    get path(): {
        resolve: (dir: string, ...paths: string[]) => string;
        normalize(p: string): string;
        join(...paths: string[]): string;
        isAbsolute(p: string): boolean;
        relative(from: string, to: string): string;
        dirname(p: string): string;
        basename(p: string, ext?: string): string;
        extname(p: string): string;
        sep: string;
        delimiter: string;
        parse(p: string): path.ParsedPath;
        format(pP: path.FormatInputPathObject): string;
        toNamespacedPath(path: string): string;
        posix: path.PlatformPath;
        win32: path.PlatformPath;
    };
    get mem(): DataView;
    get membuf(): Buffer;
    /**
     * This is a nasty hack and so deserves an apology.
     */
    sorry(): void;
    chdir(buf: i32): void;
    getcwd(buf: i32, sz: i32): number;
    progname_get(pbuf: i32): number;
    login_get(pbuf: i32): number;
    geteuid(): number;
    trace(message: i32): void;
    realpath(file_name: i32, resolved_name: i32): number;
    newfd(minfd?: number): number;
    dupfd(fd: i32, minfd: i32, cloexec: boolean): number;
    dupdesc(desc: {
        real: number;
    }): any;
    strmode(mode: i32, buf: i32): void;
    __control_setjmp(env: i32, block: i32): any;
    __control_setjmp_with_return(env: i32, block: i32): any;
    setjmp(env: i32): number;
    longjmp(env: i32, val: i32): void;
    sigsetjmp(env: i32, save_mask: i32): number;
    siglongjmp(env: i32, val: i32): void;
    vfork(): number;
    __control_fork(v1: i32, v2: i32, block: i32): void;
    execve(path: i32, argv: i32, envp: i32): void;
    posix_spawn(pid: i32, path: i32, file_actions: i32, attrp: i32, argv: i32, envp: i32): number;
    wait(stat_loc: i32): number;
    wait3(stat_loc: i32, options: i32, rusage: i32): number;
    waitBase(stat_loc: i32): number;
    userGetCString(addr: i32): Buffer;
    userGetCStrings(addr: i32): any[];
    userCStringMalloc(s: string, pbuf: i32): number;
    /**
     * Used to invoke blocks: returns a function
     * @param block a C block pointer
     */
    blockImpl(block: i32): (...args: any) => any;
    sigkill(signum: number): void;
    sigsuspend(): void;
    sigaction(signum: i32, act: i32, oact: i32): void;
    getpagesize(): number;
}
declare type ProcOptions = {
    funcTableSz?: number;
};
declare class SignalVector extends EventEmitter {
    wait: Int32Array;
    _snapshot?: Int32Array;
    handlers: sighandler[];
    debug: (...args: any) => void;
    constructor(_from?: SignalVectorProps);
    static from(props: SignalVectorProps): SignalVector;
    to(): SignalVectorProps;
    send(signum: number): void;
    receive(signums?: number[]): number;
    sweep(signums?: number[]): void;
}
declare type SignalVectorProps = {
    wait?: Int32Array;
};
declare type i32 = number;
declare type sighandler = (signum: number) => void;
declare type ChildProcessQueue = SharedQueue<Uint32Array>;
declare class ExecvCall {
    prog: string;
    argv: Buffer[];
    envp: Buffer[];
    constructor(prog: string, argv: Buffer[], envp: Buffer[]);
}
export { Proc, SignalVector, ChildProcessQueue };
